//! Rust register programming interface (RPI)
#![no_std]

use core::fmt::Display;

#[derive(Debug)]
pub enum OutOfRange {
    /// Conversion from integer type to an enumeration from a value that is
    /// too large for the enum.
    EnumValueOutOfRange,

    /// The supplied index for a block component array is larger than the
    /// length of the array.
    IndexOutOfRange,
}

impl Display for OutOfRange {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::EnumValueOutOfRange => write!(f, "enum value out of range"),
            Self::IndexOutOfRange => write!(f, "index value out of range"),
        }
    }
}

impl core::error::Error for OutOfRange {}

/// The `Platform` trait encapsulates the mechanics of how to read and write
/// registers. For example, this trait might be implemented using an ioctl
/// interface in conjunction with an operating system driver, directly
/// manipulate memory mapped register memory, send messages over a UART, etc.
pub trait Platform<AddrType, ValueType> {
    type Error;

    /// Read a register of type `T` at the given address.
    fn read<T: Default + From<ValueType>>(
        &self,
        addr: AddrType,
    ) -> Result<T, Self::Error>;

    /// Write a register of type `T` to the given address.
    fn write<T: Default + Into<ValueType>>(
        &self,
        addr: AddrType,
        value: T,
    ) -> Result<(), Self::Error>;
}

/// The `RegisterInstance` trait captures basic characteristics about a
/// register.
pub trait RegisterInstance {
    /// Return the width of this register in bits
    fn width(&self) -> usize;

    /// Return the number of copies of this register in this block
    fn copies(&self) -> u32;
}

/// The `SramInstance` trait captures the sram-specific information about the
/// register.
pub trait SramInstance {
    /// Return the msel of this register within the sram block
    fn msel_id(&self) -> u8;
}

/// The `RegisterConstruct` trait provides in interface that will return an
/// instance of a register, with its contents initialized to 0.
pub trait RegisterConstruct<T> {
    /// Construct an instance of the register initialized to its reset value.
    fn cons(&self) -> T;
    /// Construct an instance of the register initialized from the provided raw
    /// data.
    #[allow(clippy::wrong_self_convention)]
    fn from_bytes(&self, contents: &[u8]) -> Result<T, OutOfRange>;
}

/// The `RegisterAccess` trait captures basic read/write/update operations
/// on registers. Each operation requires passing in a `Platform` that knows
/// how to actually carry out reads and writes.
///
/// A register instance is typically just a wrapper around an address. The
/// methods in this trait are generic over value type. This is meant to be
/// used in conjunction with register types that are generated by the RSF
/// compiler.
pub trait RegisterAccess<T, AddrType, ValueType> {
    /// Read this the value of this register instance.
    fn read<P: Platform<AddrType, ValueType>>(
        &self,
        platform: &P,
    ) -> Result<T, P::Error>;

    /// Write a value to this register instance.
    fn write<P: Platform<AddrType, ValueType>>(
        &self,
        platform: &P,
        value: T,
    ) -> Result<(), P::Error>;

    /// Attempt a fallible update of this register instance. This write
    /// operation starts with a register initialized to the reset value, and
    /// calls a user-defined update function passed in to perform the update on
    /// the register fields.
    fn try_set<
        P: Platform<AddrType, ValueType>,
        F: FnOnce(&mut T) -> Result<(), P::Error>,
    >(
        &self,
        platform: &P,
        f: F,
    ) -> Result<(), P::Error>;

    /// Perform an update of this register instance. This write operation starts
    /// with a register initialized to the reset value, and calls a user-defined
    /// update function passed in to perform the update on the register fields.
    fn set<P: Platform<AddrType, ValueType>, F: FnOnce(&mut T)>(
        &self,
        platform: &P,
        f: F,
    ) -> Result<(), P::Error>;
    /// Attempt a fallible update of this register instance. This is a composite
    /// read/write operation with a user-defined update function passed in to
    /// perform the update on the register fields.
    fn try_update<
        P: Platform<AddrType, ValueType>,
        F: FnOnce(&mut T) -> Result<(), P::Error>,
    >(
        &self,
        platform: &P,
        f: F,
    ) -> Result<(), P::Error>;

    /// Perform an update of this register instance. This is a composite
    /// read/write operation with a user-defined update function passed in to
    /// perform the update on the register fields.
    fn update<P: Platform<AddrType, ValueType>, F: FnOnce(&mut T)>(
        &self,
        platform: &P,
        f: F,
    ) -> Result<(), P::Error>;
}

#[derive(Debug)]
pub enum DummyPlatformError {}

/// A dummy platform used only for testing.
#[derive(Default)]
pub struct DummyPlatform<AddrType> {
    phantom_data: core::marker::PhantomData<AddrType>,
}

impl<AddrType, ValueType> Platform<AddrType, ValueType>
    for DummyPlatform<AddrType>
{
    type Error = DummyPlatformError;

    fn read<T: Default>(
        &self,
        _addr: AddrType,
    ) -> Result<T, DummyPlatformError> {
        Ok(T::default())
    }
    fn write<T: Default>(
        &self,
        _addr: AddrType,
        _value: T,
    ) -> Result<(), DummyPlatformError> {
        Ok(())
    }
}
