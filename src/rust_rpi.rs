//! Rust register programming interface (RPI)

use anyhow::Result;

/// The `Platform` trait encapsulates the mechanics of how to read and write
/// registers. For example, this trait might be implemented using an ioctl
/// interface in conjunction with an operating system driver, directly
/// manipulate memory mapped register memory, send messages over a UART, etc.
pub trait Platform<AddrType> {
    /// Read a register of type `T` at the given address.
    fn read<T: Default>(&self, addr: AddrType) -> Result<T>;

    /// Write a register of type `T` to the given address.
    fn write<T: Default>(&self, addr: AddrType, value: T) -> Result<()>;
}

/// The `RegisterInstance` trait captures basic read/write/update operations
/// on registers. Each operation requires passing in a `Platform` that knows
/// how to actually carry out reads and writes.
///
/// A register instance is typically just a wrapper around an address. The
/// methods in this trait are generic over value type. This is meant to be
/// used in conjunction with register types that are generated by the RSF
/// compiler.
pub trait RegisterInstance<T, AddrType> {
    /// Read this the value of this register instance.
    fn read(&self, platform: &impl Platform<AddrType>) -> Result<T>;

    /// Write a value to this register instance.
    fn write(&self, platform: &impl Platform<AddrType>, value: T)
    -> Result<()>;

    /// Peform an update of this register instance. This is a composite
    /// read/write operation with a user-defined update function passed
    /// in to perform the update on the register fields.
    fn update(
        &self,
        platform: &impl Platform<AddrType>,
        f: fn(&mut T) -> Result<()>,
    ) -> Result<()>;
}

/// A dummy platform used only for testing.
#[cfg(test)]
#[cfg(feature = "test_generated")]
#[derive(Default)]
pub(crate) struct DummyPlatform<AddrType> {
    phantom_data: std::marker::PhantomData<AddrType>,
}

#[cfg(test)]
#[cfg(feature = "test_generated")]
impl<AddrType> Platform<AddrType> for DummyPlatform<AddrType> {
    fn read<T: Default>(&self, _addr: AddrType) -> Result<T> {
        Ok(T::default())
    }
    fn write<T: Default>(&self, _addr: AddrType, _value: T) -> Result<()> {
        Ok(())
    }
}
